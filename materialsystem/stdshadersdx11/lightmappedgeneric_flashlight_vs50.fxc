#include "common_cbuffers_def_noskinning_fxc.h"
#include "common_vs_fxc.h"
#include "lightmappedgeneric_dx11_shared_fxc.h"

//	STATIC: "NORMALMAP"				"0..1"
//  STATIC: "WORLDVERTEXTRANSITION" "0..1"
//  STATIC: "SEAMLESS"				"0..1"
//  STATIC: "DETAIL"				"0..1"
//	DYNAMIC: "DOWATERFOG"			"0..1"

static const int g_FogType					= DOWATERFOG;

struct VS_INPUT
{
	float3 vPos							: POSITION; //This HAS to match lightmappedgeneric_vs20.fxc's position input. Otherwise depth fighting errors occur on the 360
	float4 vNormal						: NORMAL;
	float2 vBaseTexCoord				: TEXCOORD0;
#if WORLDVERTEXTRANSITION
	float2 vLightmapTexCoord			: TEXCOORD1;
	float4 vColor						: COLOR0;
#endif
#if NORMALMAP
	float3 vTangentS					: TANGENT;
	float3 vTangentT					: BINORMAL;
#endif
};

struct VS_OUTPUT
{
    float4 projPos					: POSITION;
	float  fog						: FOG;

	float4 spotTexCoord				: TEXCOORD0;

#if SEAMLESS
	float3 SeamlessTexCoord			: TEXCOORD1;
#else
	float2 baseTexCoord				: TEXCOORD1;
#endif

#if NORMALMAP
	float3 tangentPosToLightVector	: TEXCOORD2;
	float2 normalMapTexCoord		: TEXCOORD3;
#else
	float3 worldPosToLightVector	: TEXCOORD2;
	float3 normal					: TEXCOORD3;
#endif

	float2 detailCoords				: TEXCOORD4;
	float4 worldPos_worldTransition	: TEXCOORD5;
	float3 vProjPos					: TEXCOORD6;
	float4 fogFactorW				: TEXCOORD7;
};

float RemapValClamped( float val, float A, float B, float C, float D)
{
	float cVal = (val - A) / (B - A);
	cVal = saturate( cVal );

	return C + (D - C) * cVal;
}

VS_OUTPUT main( const VS_INPUT v )
{
	VS_OUTPUT o = (VS_OUTPUT)0;

	float3 vObjNormal;
	DecompressVertex_Normal( v.vNormal, vObjNormal );

	float3 worldPos = mul( float4( v.vPos.xyz, 1 ), cModelMatrix ).xyz;
	float3 worldNormal = mul( vObjNormal, cModelMatrix ).xyz;

    matrix viewProj = mul( cViewMatrix, cProjMatrix );
    float4 projPos = mul( float4( worldPos, 1 ), viewProj );

	o.projPos = projPos;
	o.vProjPos.xyz = projPos.xyw;
	o.worldPos_worldTransition = float4( worldPos.xyz, 1.0f );

#if NORMALMAP
	float3 worldTangentS = mul( v.vTangentS, cModel[0] );
	float3 worldTangentT = mul( v.vTangentT, cModel[0] );
#endif

	return o;
}